import { create } from 'zustand';
import { StudyData, createDefaultStudyData } from '../types/studyTypes';
import { priorityMatrixApi, handleApiError } from '../utils/priorityMatrixApi';
import { dailyJournalApi } from '../utils/dailyJournalApi';
import { moodboardApi } from '../utils/moodboardApi';

const useStudyStore = create((set, get) => ({
  // Initial state
  studyData: createDefaultStudyData(),
  isLoading: false,
  error: null,
  
  // Actions
  setStudyData: (data) => set({ 
    studyData: new StudyData(data),
    error: null 
  }),
  
  setLoading: (loading) => set({ isLoading: loading }),
  
  setError: (error) => set({ error }),
  
  // Task management
  addTask: (taskData, selectedDate = null) => set((state) => {
    const now = new Date();
    const taskDate = selectedDate || now;
    
    const newTask = {
      id: Date.now().toString(), // Temporary ID, should be generated by backend
      ...taskData,
      created_at: now.toISOString(),
      updated_at: now.toISOString(),
      // Frontend convenience fields for filtering in calendar
      task_date: taskDate.toISOString().split('T')[0],
      // Mirror backend due_date (prefer backend provided value if present)
      due_date: taskData?.due_date || taskDate.toISOString().split('T')[0]
    };
    
    // Debug: Log task creation
    console.log('Adding task:', {
      title: newTask.title,
      task_date: newTask.task_date,
      selectedDate: selectedDate?.toISOString().split('T')[0],
      currentDate: now.toISOString().split('T')[0]
    });
    
    const updatedMatrix = {
      ...state.studyData.eisenhower_matrix,
      list_of_tasks: [...state.studyData.eisenhower_matrix.list_of_tasks, newTask]
    };
    
    return {
      studyData: {
        ...state.studyData,
        eisenhower_matrix: updatedMatrix
      }
    };
  }),
  
  // Sync add task with backend
  syncAddTask: async (taskData, selectedDate = null) => {
    try {
      const dueDateStr = selectedDate ? selectedDate.toISOString().split('T')[0] : undefined;
      const payload = dueDateStr ? { ...taskData, due_date: dueDateStr } : { ...taskData };
      const backendTask = await priorityMatrixApi.createTask(payload);
      // Update store with backend response
      get().addTask(backendTask, selectedDate);
      return backendTask;
    } catch (error) {
      console.error('Failed to sync task creation:', handleApiError(error));
      throw error;
    }
  },
  
  updateTask: (taskId, updates) => set((state) => {
    const updatedTasks = state.studyData.eisenhower_matrix.list_of_tasks.map(task =>
      task.id === taskId 
        ? { ...task, ...updates, updated_at: new Date().toISOString() }
        : task
    );
    
    const updatedMatrix = {
      ...state.studyData.eisenhower_matrix,
      list_of_tasks: updatedTasks
    };
    
    return {
      studyData: {
        ...state.studyData,
        eisenhower_matrix: updatedMatrix
      }
    };
  }),
  
  // Sync update task with backend
  syncUpdateTask: async (taskId, updates) => {
    try {
      // Get the current task to ensure we have all required fields
      const currentTasks = get().studyData.eisenhower_matrix.list_of_tasks;
      const currentTask = currentTasks.find(t => t.id === taskId);
      
      if (!currentTask) {
        throw new Error('Task not found');
      }
      
      // Merge updates with current task data to ensure all required fields are present
      const completeTaskData = {
        id: taskId,
        quadrant: currentTask.quadrant,
        title: currentTask.title,
        description: currentTask.description,
        status: currentTask.status,
        ...updates // Override with any updates
      };
      
      const backendTask = await priorityMatrixApi.updateTask(completeTaskData);
      // Update store with backend response
      get().updateTask(taskId, backendTask);
      return backendTask;
    } catch (error) {
      console.error('Failed to sync task update:', handleApiError(error));
      throw error;
    }
  },
  
  deleteTask: (taskId) => set((state) => {
    const updatedTasks = state.studyData.eisenhower_matrix.list_of_tasks.filter(
      task => task.id !== taskId
    );
    
    const updatedMatrix = {
      ...state.studyData.eisenhower_matrix,
      list_of_tasks: updatedTasks
    };
    
    return {
      studyData: {
        ...state.studyData,
        eisenhower_matrix: updatedMatrix
      }
    };
  }),
  
  // Sync delete task with backend
  syncDeleteTask: async (taskId) => {
    try {
      await priorityMatrixApi.deleteTask(taskId);
      // Update store after successful deletion
      get().deleteTask(taskId);
    } catch (error) {
      console.error('Failed to sync task deletion:', handleApiError(error));
      throw error;
    }
  },
  
  // Pomodoro timer management
  updatePomodoroTimer: (updates) => set((state) => ({
    studyData: {
      ...state.studyData,
      pomodoro_timer: {
        ...state.studyData.pomodoro_timer,
        ...updates
      }
    }
  })),
  
  // Sound management
  updateSound: (updates) => set((state) => ({
    studyData: {
      ...state.studyData,
      sound: {
        ...state.studyData.sound,
        ...updates
      }
    }
  })),
  
  // Daily data management
  addDailyData: (dailyData) => set((state) => ({
    studyData: {
      ...state.studyData,
      stress_jounral_data: [...state.studyData.stress_jounral_data, dailyData]
    }
  })),
  
  // Sync add daily data with backend
  syncAddDailyData: async (dailyData) => {
    try {
      await dailyJournalApi.createEntry(dailyData);
      // Update store after successful creation
      get().addDailyData(dailyData);
    } catch (error) {
      console.error('Failed to sync daily data creation:', handleApiError(error));
      throw error;
    }
  },
  
  updateDailyData: (day, month, year, updates) => set((state) => {
    const updatedDailyData = state.studyData.stress_jounral_data.map(daily =>
      daily.day === day && daily.month === month && daily.year === year
        ? { ...daily, ...updates }
        : daily
    );
    
    return {
      studyData: {
        ...state.studyData,
        stress_jounral_data: updatedDailyData
      }
    };
  }),
  
  // Sync update daily data with backend
  syncUpdateDailyData: async (date, updates) => {
    try {
      await dailyJournalApi.updateEntry(date, updates);
      // Parse date to get day, month, year
      const [year, month, day] = date.split('-').map(Number);
      // Update store after successful update
      get().updateDailyData(day, month, year, updates);
    } catch (error) {
      console.error('Failed to sync daily data update:', handleApiError(error));
      throw error;
    }
  },
  
  // Delete daily data
  deleteDailyData: (date) => set((state) => {
    const [year, month, day] = date.split('-').map(Number);
    const updatedDailyData = state.studyData.stress_jounral_data.filter(
      daily => !(daily.day === day && daily.month === month && daily.year === year)
    );
    
    return {
      studyData: {
        ...state.studyData,
        stress_jounral_data: updatedDailyData
      }
    };
  }),
  
  // Sync delete daily data with backend
  syncDeleteDailyData: async (date) => {
    try {
      await dailyJournalApi.deleteEntry(date);
      // Update store after successful deletion
      get().deleteDailyData(date);
    } catch (error) {
      console.error('Failed to sync daily data deletion:', handleApiError(error));
      throw error;
    }
  },
  
  // Moodboard data management
  updateMoodboardData: (updates) => set((state) => ({
    studyData: {
      ...state.studyData,
      moodboard_data: {
        ...state.studyData.moodboard_data,
        ...updates
      }
    }
  })),
  
  // Sync moodboard data with backend
  syncMoodboardData: async (moodboardData) => {
    try {
      await moodboardApi.updateMoodboardData(moodboardData);
      // Update store after successful update
      get().updateMoodboardData(moodboardData);
    } catch (error) {
      console.error('Failed to sync moodboard data:', handleApiError(error));
      throw error;
    }
  },
  
  // API integration - fetch all data from backend
  fetchStudyData: async () => {
    set({ isLoading: true, error: null });
    
    try {
      // Fetch all data in parallel
      const [tasks, dailyEntries, moodboard] = await Promise.all([
        priorityMatrixApi.getTasks().catch(() => []),
        dailyJournalApi.getAllEntries().catch(() => []),
        moodboardApi.getMoodboardData().catch(() => ({ study_mode: true, data: {} }))
      ]);

      // Update store with fetched data
      set((state) => ({
        studyData: {
          ...state.studyData,
          eisenhower_matrix: {
            ...state.studyData.eisenhower_matrix,
            list_of_tasks: tasks
          },
          stress_jounral_data: dailyEntries || [],
          moodboard_data: moodboard
        },
        isLoading: false,
        error: null
      }));
    } catch (error) {
      // Silently fall back to default data when API is unavailable
      console.warn('Failed to fetch study data, using defaults:', error);
      set({ 
        studyData: createDefaultStudyData(), 
        isLoading: false,
        error: null // Don't show error in UI when API is unavailable
      });
    }
  },
  
  // Fetch priority matrix tasks from backend (optionally for a specific due date)
  fetchPriorityMatrixTasks: async (dueDateStr = null) => {
    set({ isLoading: true, error: null });
    
    try {
      const tasks = await priorityMatrixApi.getTasks(null, dueDateStr);
      set((state) => ({
        studyData: {
          ...state.studyData,
          eisenhower_matrix: {
            ...state.studyData.eisenhower_matrix,
            list_of_tasks: tasks
          }
        },
        isLoading: false
      }));
    } catch (error) {
      console.error('Failed to fetch priority matrix tasks:', handleApiError(error));
      set({ isLoading: false });
    }
  },
  
  // Getters for computed values
  getTasksByQuadrant: (quadrant) => {
    const { studyData } = get();
    return studyData.eisenhower_matrix.list_of_tasks.filter(task => task.quadrant === quadrant);
  },
  
  getTasksByStatus: (status) => {
    const { studyData } = get();
    return studyData.eisenhower_matrix.list_of_tasks.filter(task => task.status === status);
  },
  
  getDailyDataByDate: (day, month, year) => {
    const { studyData } = get();
    return studyData.stress_jounral_data.find(daily => 
      daily.day === day && daily.month === month && daily.year === year
    );
  },
  
  getTotalTasks: () => {
    const { studyData } = get();
    return studyData.eisenhower_matrix.list_of_tasks.length;
  },
  
  getCompletedTasks: () => {
    const { studyData } = get();
    return studyData.eisenhower_matrix.list_of_tasks.filter(task => task.status === 'completed').length;
  }
}));

export default useStudyStore;
